import FRP.Helm
import qualified FRP.Helm.Keyboard as Keyboard
import qualified FRP.Helm.Window as Window
import qualified FRP.Helm.Time as Time

data State = State { mx :: Double, my :: Double,
                     vx :: Double, vy :: Double }

{-| Given (dx, dy) and a state, returns a new state with updated velocities |-}
accel :: (Int, Int) -> State -> State
accel (dx, dy) state = state { mx = mx state, my = my state,
                               vx = realToFrac dx + vx state,
                               vy = realToFrac dy + vy state }

{-| Given a Time value, returns a new state with updated position |-}
tick :: Time.Time -> State -> State
tick dt state = state { mx = mx state + dt * vx state,
                        my = my state + dt * vy state,
                        vx = vx state, vy = vy state }

{-| Given a viewport size, returns rendering functions (State -> Element) |-}
render :: (Int, Int) -> State -> Element
render (w, h) (State { vx = vx, vy = vy }) =
  centeredCollage w h [move (vx, vy) $ filled red $ square 100]

main :: IO ()
main =
  do
    engine <- startup defaultConfig
    -- read as "run(engine((render <~ (Window.dimensions engine)) ~~ stepper))"
    -- where "Window.dimensions engine" is a signal generator for viewport sizes,
    -- "render <~" that is a rendering function signal generator, and
    -- that "~~ stepper" applies those functions to states generated by the
    -- stepper signal generator
    run engine $ render <~ Window.dimensions engine ~~ stepper
  where
    state = State { vx = 0, vy = 0 }
    stepper = foldp accel state Keyboard.arrows
